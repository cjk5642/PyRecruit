<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>recruits.ncaaf.utils API documentation</title>
<meta name="description" content="Utilities class for NCAAF Players and Teams" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>recruits.ncaaf.utils</code></h1>
</header>
<section id="section-intro">
<p>Utilities class for NCAAF Players and Teams</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Utilities class for NCAAF Players and Teams
&#34;&#34;&#34;

import requests
from .datamodels import *
from bs4 import BeautifulSoup
from typing import Union, List, Tuple, Dict

HEADERS = {
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36&#39;,
}

class Staff:
    &#34;&#34;&#34;Staff class that produces the staff member given the webpage
    &#34;&#34;&#34;
    def __init__(self, name_id:str = None, url:str = None, soup:BeautifulSoup = None):
        self.name_id = name_id
        self.url = url
        self.soup = soup
        self.page = self._gain_primary()

    def _gain_primary(self) -&gt; BeautifulSoup:
        &#34;&#34;&#34;Method to obtain the BeautifulSoup page

        Returns:
            BeautifulSoup: page given the different identifiers
        &#34;&#34;&#34;
              
        if self.url:
            page = requests.get(self.url, headers = HEADERS)
            soup = BeautifulSoup(page.content, &#39;html.parser&#39;)
            return soup
        
        if self.name_id:
            url = f&#34;https://247sports.com/Coach/{self.name_id}/&#34;
            page = requests.get(url, headers = HEADERS)
            soup = BeautifulSoup(page.content, &#39;html.parser&#39;)
            return soup
        
        return self.soup
        
    def _get_meta(self, page: BeautifulSoup) -&gt; Dict:
        &#34;&#34;&#34;Collect the metadata on the staff member

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Dict: metadata of the coach like job position, alma mater, and age
        &#34;&#34;&#34;
        data = {}

        # get name
        data[&#39;name&#39;] = page.find(&#39;h1&#39;, class_=&#39;name&#39;).text.strip()

        # get metrics
        metrics_list = page.find(&#34;ul&#34;, class_=&#39;metrics-list&#39;).find_all(&#39;li&#39;)
        for ml in metrics_list:
            met = ml.find_all(&#39;span&#39;)
            if met[0].text.lower() == &#39;job&#39;:
                data[&#39;position&#39;] = met[1].text.strip()

        # get alma mater
        coach_details = page.find(&#34;ul&#34;, class_=&#39;details coach&#39;)
        if coach_details:
            coach_details = coach_details.find_all(&#39;li&#39;)
            for cd in coach_details:
                if cd.get(&#39;class&#39;) == &#39;coach-alma-mater-item&#39;:
                    data[&#39;alma_mater&#39;] = cd.find_all(&#39;span&#39;)[-1].strip()

        # get vitals and team info
        team = page.find(&#39;section&#39;, class_=&#39;team-block&#39;)
        if team:
            data[&#39;college&#39;] = team.find(&#39;h2&#39;).text.strip()
            vitals = team.find(&#39;ul&#39;, class_=&#39;vitals&#39;).find_all(&#39;li&#39;)
            for v in vitals:
                v = v.find_all(&#39;span&#39;)
                if v[0] == &#39;Age&#39;:
                    data[&#39;staff_member_age&#39;] = int(v[1]) if v[1] else None

        return data
    
    def _get_ratings(self, page: BeautifulSoup) -&gt; Dict:
        &#34;&#34;&#34;Collect the ratings of the staff member

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Dict: Ratings data of the staff member like number of commits avg rank and so on.
        &#34;&#34;&#34;

        data = {}
        rankings = page.find(&#39;section&#39;, class_=&#39;rankings-section&#39;)
        if not rankings:
            return None
        
        rankings = rankings.find_all(&#39;li&#39;)
        non_conf = [&#34;commits&#34;, &#39;avg_rtg&#39;, &#39;natl_rk&#39;, &#39;star_5&#39;, &#39;star_4&#39;, &#39;star_3&#39;]
        for rank in rankings:
            # fix system to rearrange if the string starts with a number like 5
            rank_name = rank.find(&#39;b&#39;).text.replace(&#39;.&#39;, &#39;&#39;).replace(&#39; &#39;, &#39;_&#39;).replace(&#39;-&#39;, &#34;_&#34;).lower()
            if rank_name[0].isdigit():
                num, star = rank_name.split(&#39;_&#39;)
                rank_name = &#34;_&#34;.join([star, num])

            rank_value = rank.find(&#39;a&#39;)
            if rank_value:
                rank_value = rank_value.find(&#39;strong&#39;).text.strip()
                if rank_name in non_conf:
                    data[rank_name] = rank_value
                else:
                    data[&#39;conference&#39;] = rank_value
        return data

    def _get_top_commits(self, page: BeautifulSoup) -&gt; Union[None, List[TopCommit]]:
        &#34;&#34;&#34;Collect the top commits of the coach.

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, List[TopCommit]]: The metadata of the player if found
        &#34;&#34;&#34;
        commits = page.find_all(&#39;ul&#39;, class_=&#39;commits-details&#39;)
        if not commits:
            return None

        details = []
        for commit in commits:
            _, name, position, height_weight, rating, commitment = commit.find_all(&#34;li&#34;)

            # get name
            recruit_name = name.find(&#39;a&#39;, class_=&#39;player&#39;).text
            location = &#39; &#39;.join([string.strip() for string in name.find_all(&#34;span&#34;)])

            # position
            position = position.find(&#39;span&#39;).text.strip()

            # find height and weight
            height, weight = height_weight.find(&#39;span&#39;).text.split(&#34; / &#34;)

            # find rating and stars
            stars = len(rating.find_all(&#34;span&#34;, class_=&#34;icon-starsolid yellow&#34;))
            rating = float(rating.find(&#39;span&#39;, class_=&#34;rating&#34;).text)

            # find commitment
            college = commitment.find(&#34;a&#34;, class_=&#39;player-institution&#39;).find(&#39;img&#39;)[&#39;alt&#39;].strip()
            commitment_date = commitment.find(&#34;span&#34;, class_=&#39;commit-date&#39;).text.strip()

            commit = TopCommit(
                name = recruit_name, location = location, position = position,
                height = height, weight = weight, stars = stars, rating = rating,
                college = college, commitment_date = commitment_date
            )
            details.append(commit)

        return details

    def _get_coach_history(self, page: BeautifulSoup) -&gt; Union[None, List[CoachHistory]]:
        &#34;&#34;&#34;Collect the history of the coach such as job positions

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, List[CoachHistory]]: _description_
        &#34;&#34;&#34;
        coach_history = page.find(&#34;section&#34;, class_=&#39;coach-history&#39;)
        if not coach_history:
            return None
        
        coach_history = coach_history.find(&#39;div&#39;, class_=&#39;body&#39;).find_all(&#39;li&#39;)
        data = []
        for position in coach_history:
            college, (years, job) = position.find(&#39;img&#39;)[&#39;alt&#39;], position.find_all(&#39;span&#39;)
            years, job = years.text.strip(), job.text.strip()

            coachhistory = CoachHistory(college=college, year=years, position=job)
            data.append(coachhistory)
        return data

    @property
    def member(self) -&gt; StaffMember:
        &#34;&#34;&#34;Output property for the Staff Member

        Returns:
            StaffMember: Staffmember dataclass that contains the just collected data
        &#34;&#34;&#34;
        meta = self._get_meta(self.page)
        ratings = self._get_ratings(self.page)
        commits = self._get_top_commits(self.page)
        coach_history = self._get_coach_history(self.page)

        if ratings:
            return StaffMember(
                **meta, **ratings, top_commits=commits, coach_history=coach_history
            )
        else:
            return StaffMember(
                **meta, top_commits=commits, coach_history=coach_history
            )

class Connections:
    def __init__(self, soup: BeautifulSoup):
        self.soup = soup
    
    @property
    def connections(self) -&gt; Union[None, List[Connection]]:
        &#34;&#34;&#34;Collect the connecions to the player

        Returns:
            Union[None, List[Connection]]: Data on the connections to the player
        &#34;&#34;&#34;
        pedigree = self.soup.find(&#39;section&#39;, class_ = &#39;pedigree&#39;)
        if not pedigree:
            return None

        pedigree = pedigree.find(&#39;div&#39;, class_ = &#39;body&#39;).find_all(&#39;li&#39;)
        connections = []
        for ped in pedigree:
            name = ped.find(&#39;a&#39;, class_ = &#39;name&#39;)
            if name:
                name = name.text
            else:
                name = ped.find(&#39;b&#39;, class_ = &#39;name&#39;).text

            relation = ped.find(&#39;span&#39;, class_ = &#39;relation&#39;).text
            accolades = ped.find(&#39;span&#39;, class_=&#39;accolades&#39;)
            accolades = &#34;&#34;.join([string for string in accolades.strings])
            connection = Connection(
                name = name, relation=relation, accolades=accolades
            )
            connections.append(connection)
        return connections

class CollegeRecruitingInterest:
    def __init__(self, soup: BeautifulSoup):
        self.soup = soup
    
    def _examine_more_colleges(self, url: str) -&gt; List[CollegeInterest]:
        &#34;&#34;&#34;Method to parse over page if there is long list of colleges. Congrats!

        Args:
            url (str): the url to the webpage that contains list of colleges

        Returns:
            List[CollegeInterest]: Data of all colleges that actively recruited recruit
        &#34;&#34;&#34;
        school_list = []
        page = requests.get(url, headers=HEADERS)
        soup = BeautifulSoup(page.content, &#34;html.parser&#34;)
        interests = soup.find(&#34;ul&#34;, class_ = &#34;recruit-interest-index_lst&#34;)
        first_blocks = interests.find_all(&#34;div&#34;, class_=&#39;first_blk&#39;)
        second_blocks = interests.find_all(&#39;div&#39;, class_=&#39;secondary_blk&#39;)
        for first_block, second_block in zip(first_blocks, second_blocks):
            
            # collect college name
            first_block_a = first_block.find_all(&#39;a&#39;)
            college_name = &#34;&#34;.join(first_block_a[0].text.split())

            # collect college statuses
            college_status = first_block.find(&#39;span&#39;, class_ = &#39;status&#39;)
            college_status_text = college_status.find(&#39;span&#39;, class_=&#39;grey&#39;)
            if college_status_text:
                college_status_text = &#34;Signed&#34;
            else:
                college_status_text = college_status.find(&#39;span&#39;).text
            
            # collect the status of signature or not
            college_status_date = college_status.find(&#34;a&#34;)
            if college_status_date:
                college_status_date = college_status_date.text
                college_status_date = college_status_date.translate(str.maketrans(&#34;&#34;, &#34;&#34;, &#34;()&#34;))
            else:
                college_status_date = None

            # collect visit
            visit = second_block.find(&#39;span&#39;, class_=&#39;visit&#39;).text
            if &#39;-&#39; in visit:
                visit = None
            
            # collect offer
            offer = second_block.find(&#39;span&#39;, class_=&#39;offer&#39;).text.strip()
            if &#39;yes&#39; in offer.lower():
                offer = True
            else:
                offer = False

            # collect recruited by
            recruited_by = second_block.find(&#34;ul&#34;, class_=&#39;interest-details_lst&#39;)
            if not recruited_by:
                recruiters = None
            else:
                recruited_by = recruited_by.find_all(&#34;li&#34;)[1:]
                recruiters = [Staff(url = recruiter.find(&#34;a&#34;)[&#39;href&#39;]).member for recruiter in recruited_by]

            school = CollegeInterest(
                college=college_name, status=college_status_text,
                status_date=college_status_date, visit=visit, offered=offer,
                recruited_by=recruiters
            )
            school_list.append(school)      
        return school_list

    @property
    def college_interest(self) -&gt; Union[None, List[CollegeInterest]]:
        &#34;&#34;&#34;Method to output the data of college

        Returns:
            Union[None, List[CollegeInterest]]: Data of all colleges interested in the recruit
        &#34;&#34;&#34;
        view_all_colleges = self.soup.find(&#39;a&#39;, class_ = &#34;college-comp__view-all&#34;)
        school_list = []
        if view_all_colleges:
            school_list = self._examine_more_colleges(view_all_colleges[&#39;href&#39;])
        else:
            school_list = None
        return school_list

class BackgroundSkills:
    def __init__(self, soup: BeautifulSoup):
        self.soup = soup

    def _examine_background(self, page: BeautifulSoup) -&gt; Union[None, str]:
        &#34;&#34;&#34;Collect background info on the recruit other. Like their biography

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, str]: Biography text of the recruit
        &#34;&#34;&#34;
        background = page.find(&#34;section&#34;, class_=&#34;athletic-background&#34;)
        if not background:
            return None

        # extract biography text
        background = background.find(&#34;div&#34;, class_=&#39;body&#39;)
        background_text = &#34; &#34;.join([string.strip() for string in background.strings]).replace(&#34;\r&#34;, &#39;&#39;).strip()
        return background_text

    
    def _examine_skills(self, page: BeautifulSoup) -&gt; Union[None, Skills]:
        &#34;&#34;&#34;Method to find the skills of the player if listed

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, Skills]: Skills Dataclass that consist of the recruits skills
        &#34;&#34;&#34;
        skills = page.find(&#34;section&#34;, class_=&#39;skills&#39;)
        if not skills:
            return None

        # collect the skills
        skills = skills.find(&#39;div&#39;, class_=&#39;body&#39;).find(&#39;ul&#39;).find_all(&#39;li&#39;)
        skills_dict = {}
        for skill in skills:
            skill_text = skill.find(&#34;span&#34;, class_=&#39;text&#39;).text
            skill_rating = int(skill.find(&#34;b&#34;).text)
            skills_dict[skill_text] = skill_rating
        return Skills.from_kwargs(**skills_dict)

    @property
    def background_skills(self) -&gt; Tuple[Union[None, str], Union[None, Skills]]:
        &#34;&#34;&#34;Method to output the background and skills

        Returns:
            Tuple[Union[None, str], Union[None, Skills]]: The background and skills of the player
        &#34;&#34;&#34;
        background_skills = self.soup.find(&#34;div&#34;, class_=&#34;background-and-skills&#34;)
        background = self._examine_background(background_skills)
        skills = self._examine_skills(background_skills)
        return background, skills

class Evaluators:
    def __init__(self, soup: BeautifulSoup):
        self.soup = soup

    def _examine_multiple_evaluators(self, page: BeautifulSoup) -&gt; List[Evaluator]:
        &#34;&#34;&#34;Find evaluators data if the webpage allows for multiple evaluators

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            List[Evaluator]: Evaluator dataclasses of the evaluators found evaluating
            the recruit.
        &#34;&#34;&#34;

        evaluators = page.find(&#34;section&#34;, class_=&#34;main-content list-content&#34;)
        evaluators_list = evaluators.find(&#34;ul&#34;, class_=&#39;evaluation-list&#39;).find_all(&#34;li&#34;)
        evaluators_list = list()
        for evaluator in evaluators_list:
            eval_id = evaluator.get(&#39;id&#39;)
            eval_id = int(eval_id) if eval_id else None
            eval_list = evaluator.find(&#34;ul&#34;, class_ = &#34;highlights-list&#34;)
            if eval_list:

                # evaluator name and region0
                evaluator_eval = eval_list.find(&#34;li&#34;, class_=&#34;eval-meta evaluator&#34;)
                name = evaluator_eval.find(&#34;b&#34;, class_=&#34;text&#34;).text
                region = evaluator_eval.find(&#34;span&#34;, class_=&#34;uppercase&#34;).text

                # get projection
                evaluator_projection = eval_list.find(&#34;li&#34;, class_=&#34;eval-meta projection&#34;)
                projection = evaluator_projection.find(&#34;b&#34;, class_=&#34;text&#34;).text

                # get comparison
                evaluator_comparison = eval_list.find_all(&#39;li&#39;, class_=&#39;eval-meta&#39;, partial=False)[-1]
                comparison = evaluator_comparison.find(&#34;a&#34;, attrs = {&#34;target&#34;: &#34;_blank&#34;})
                if comparison:
                    comparison = comparison.text
                else:
                    comparison = None
                
                # see if there is a comparison team
                comparison_team = evaluator_comparison.find(&#34;span&#34;, class_=&#34;uppercase&#34;)
                if comparison_team:
                    comparison_team = comparison_team.text
                else:
                    comparison_team = None

                # get evaluation date and text
                evaluation_data = evaluator.find(&#34;p&#34;, class_=&#34;eval-text&#34;)
                evaluation_date = evaluation_data.find(&#34;strong&#34;, class_=&#34;eval-date&#34;).text.strip()
                evaluation_text = evaluation_data.text.strip().split(&#34;\n&#34;)[-1].strip()

                evaluators_dataclass = Evaluator(
                    id = eval_id, name = name, region = region, projection = projection, comparison=comparison,
                    comparison_team=comparison_team, evaluation_date=evaluation_date, evaluation=evaluation_text
                )
                evaluators_list.append(evaluators_dataclass)
        return evaluators_list

    def _examine_single_page_evaluators(self, page: BeautifulSoup) -&gt; Union[None, Evaluator]:
        &#34;&#34;&#34;Find evaluator if there is no external webpage.

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, Evaluator]: Evaluator data class that consists of Evaluator metadata
        &#34;&#34;&#34;
        # get highlights
        highlights = page.find(&#34;section&#34;, class_=&#34;highlights&#34;)
        if not highlights:
            return None

        # get evaluator metadata
        eval_date = highlights.find(&#39;div&#39;).find(&#39;h4&#39;).text.split(&#34; &#34;)[-1]
        evaluator = highlights.find(&#34;div&#34;, class_=&#39;evaluator&#39;)
        name = evaluator.find(&#34;b&#34;, class_=&#39;text&#39;).text
        region = evaluator.find(&#39;span&#39;, class_=&#39;uppercase&#39;).text

        # get projections
        projection = highlights.find(&#34;div&#34;, class_=&#39;projection&#39;).find(&#39;b&#39;).text

        # get comparison
        comparison = highlights.find_all(&#39;div&#39;)[-1]
        comparison_name = comparison.find(&#39;a&#39;).text
        comparison_team = comparison.find(&#34;span&#34;).text

        # get evaluations
        evaluation = page.find(&#34;p&#34;, class_=&#39;eval-text&#39;).get_text().strip()

        # store evaluation
        evaluators_dataclass = Evaluator(
            name = name, region = region, projection = projection, comparison=comparison_name,
            comparison_team=comparison_team, evaluation_date=eval_date, evaluation=evaluation
        )
        
        return evaluators_dataclass

    @property
    def evaluator(self) -&gt; Union[None, Tuple[List[Evaluator], Union[None, str], Union[None, Skills]], Tuple[Evaluator, Union[None, str], Union[None, Skills]]]:
        &#34;&#34;&#34;Output method to collect the Evaluators

        Returns:
            Union[None, 
                  Tuple[List[Evaluator], Union[None, str], Union[None, Skills]], 
                  Tuple[Evaluator, Union[None, str], Union[None, Skills]]]: Evaluator dataclasses with
                  the background and skills dataclasses embedded
        &#34;&#34;&#34;
        scouting_report = self.soup.find(&#34;section&#34;, class_=&#34;scouting-report&#34;)
        if not scouting_report:
            return None

        # collect evaluators
        evaluations = scouting_report.find(&#34;header&#34;).find(&#39;a&#39;, class_=&#39;view-all-eval-link&#39;)
        if evaluations:
            url = evaluations[&#39;href&#39;]
            page = requests.get(url, headers = HEADERS)
            soup = BeautifulSoup(page.content, &#39;lxml&#39;)
            evaluators_list = self._examine_multiple_evaluators(soup)
            background, skills = BackgroundSkills(scouting_report).background_skills

        else:
            evaluators = self.soup.find(&#39;section&#39;, class_=&#39;scouting-report&#39;)
            evaluators_list = self._examine_single_page_evaluators(evaluators)
            background, skills = BackgroundSkills(evaluators).background_skills

        return evaluators_list, background, skills

class Ratings247:
    def __init__(self, soup: BeautifulSoup, pos: str, state: str):
        self.soup = soup
        self.pos = pos
        self.state = state

    def _find_ratings_composite_helper(self, soup: BeautifulSoup, it: BeautifulSoup) -&gt; Dict:
        &#34;&#34;&#34;Collect the composite ratings of the recruit (247Sports Composite)

        Args:
            soup (BeautifulSoup): webpage to be scraped
            it (BeautifulSoup): position on webpage

        Returns:
            Dict: data that consists of the different composite scores
        &#34;&#34;&#34;
        data = {}
        data[&#39;composite_score&#39;] = soup.find(&#34;div&#34;, class_ = &#34;rank-block&#34;).text
        if data[&#39;composite_score&#39;] == &#39;N/A&#39;:
            data[&#39;composite_score&#39;] = None
        else:
            data[&#39;composite_score&#39;] = float(&#34;&#34;.join(data[&#39;composite_score&#39;].split())) if data[&#39;composite_score&#39;] else None
        
        rank_list = it.find(&#34;ul&#34;, class_ = &#34;ranks-list&#34;).find_all(&#34;li&#34;)
        for rl in rank_list:
            rank_name, rank_value = rl.find(&#34;b&#34;).text, rl.find(&#34;a&#34;).find(&#34;strong&#34;).text
            if rank_value == &#39;N/A&#39;:
                rank_value = None

            if rank_name == &#39;Natl.&#39;:
                data[&#39;national_composite_rank&#39;] = int(rank_value) if rank_value else None
            if rank_name == self.pos:
                data[&#39;position_composite_rank&#39;] = int(rank_value) if rank_value else None
            if rank_name == self.state:
                data[&#39;state_composite_rank&#39;] = int(rank_value) if rank_value else None
        return data

    def _find_ratings_normal_helper(self, soup: BeautifulSoup, it: BeautifulSoup) -&gt; Dict:
        &#34;&#34;&#34;Collect the normal ratings of the recruit (247Sports)

        Args:
            soup (BeautifulSoup): webpage to be scraped
            it (BeautifulSoup): position on webpage

        Returns:
            Dict: data that consists of the different normal scores
        &#34;&#34;&#34;
        data = {}
        data[&#39;normal_score&#39;] = soup.find(&#34;div&#34;, class_ = &#34;rank-block&#34;).text.strip()
        if data[&#39;normal_score&#39;] == &#39;N/A&#39;:
            data[&#39;normal_score&#39;] = None
        else:
            data[&#39;normal_score&#39;] = float(&#34;&#34;.join(data[&#39;normal_score&#39;].split())) if data[&#39;normal_score&#39;] else None

        rank_list = it.find(&#34;ul&#34;, class_ = &#34;ranks-list&#34;).find_all(&#34;li&#34;)
        for rl in rank_list:
            rank_name, rank_value = rl.find(&#34;b&#34;).text, rl.find(&#34;a&#34;).find(&#34;strong&#34;).text
            # change n/a to None
            if rank_value == &#39;N/A&#39;:
                rank_value = None

            if rank_name == &#39;Natl.&#39;:
                data[&#39;national_normal_rank&#39;] = int(rank_value) if rank_value else None
            if rank_name == self.pos:
                data[&#39;position_normal_rank&#39;] = int(rank_value) if rank_value else None
            if rank_name == self.state:
                data[&#39;state_normal_rank&#39;] = int(rank_value) if rank_value else None
        return data

    @property
    def ratings(self) -&gt; Ratings:
        &#34;&#34;&#34;Method to output Ratings dataclass that consist of Normal and
        Composite ratings.

        Returns:
            Ratings: Ratings dataclass that consist of Normal and 
            composite ratings.
        &#34;&#34;&#34;
        ratings_sections = self.soup.find_all(&#34;section&#34;, class_ = &#34;rankings-section&#34;)
        data = {}
        for rs in ratings_sections:
            title = rs.find(&#34;h3&#34;, class_ = &#39;title&#39;).text
            if &#39;composite&#39; in title.lower():
                ranking = rs.find(&#34;div&#34;, class_ = &#34;ranking&#34;)
                new_data = self._find_ratings_composite_helper(ranking, rs)
                data.update(new_data)
                
            else:
                ranking = rs.find(&#34;div&#34;, class_ = &#34;ranking&#34;)
                new_data = self._find_ratings_normal_helper(ranking, rs)
                data.update(new_data)

        return Ratings(**data)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="recruits.ncaaf.utils.BackgroundSkills"><code class="flex name class">
<span>class <span class="ident">BackgroundSkills</span></span>
<span>(</span><span>soup: bs4.BeautifulSoup)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackgroundSkills:
    def __init__(self, soup: BeautifulSoup):
        self.soup = soup

    def _examine_background(self, page: BeautifulSoup) -&gt; Union[None, str]:
        &#34;&#34;&#34;Collect background info on the recruit other. Like their biography

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, str]: Biography text of the recruit
        &#34;&#34;&#34;
        background = page.find(&#34;section&#34;, class_=&#34;athletic-background&#34;)
        if not background:
            return None

        # extract biography text
        background = background.find(&#34;div&#34;, class_=&#39;body&#39;)
        background_text = &#34; &#34;.join([string.strip() for string in background.strings]).replace(&#34;\r&#34;, &#39;&#39;).strip()
        return background_text

    
    def _examine_skills(self, page: BeautifulSoup) -&gt; Union[None, Skills]:
        &#34;&#34;&#34;Method to find the skills of the player if listed

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, Skills]: Skills Dataclass that consist of the recruits skills
        &#34;&#34;&#34;
        skills = page.find(&#34;section&#34;, class_=&#39;skills&#39;)
        if not skills:
            return None

        # collect the skills
        skills = skills.find(&#39;div&#39;, class_=&#39;body&#39;).find(&#39;ul&#39;).find_all(&#39;li&#39;)
        skills_dict = {}
        for skill in skills:
            skill_text = skill.find(&#34;span&#34;, class_=&#39;text&#39;).text
            skill_rating = int(skill.find(&#34;b&#34;).text)
            skills_dict[skill_text] = skill_rating
        return Skills.from_kwargs(**skills_dict)

    @property
    def background_skills(self) -&gt; Tuple[Union[None, str], Union[None, Skills]]:
        &#34;&#34;&#34;Method to output the background and skills

        Returns:
            Tuple[Union[None, str], Union[None, Skills]]: The background and skills of the player
        &#34;&#34;&#34;
        background_skills = self.soup.find(&#34;div&#34;, class_=&#34;background-and-skills&#34;)
        background = self._examine_background(background_skills)
        skills = self._examine_skills(background_skills)
        return background, skills</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="recruits.ncaaf.utils.BackgroundSkills.background_skills"><code class="name">var <span class="ident">background_skills</span> : Tuple[Optional[None], Optional[None]]</code></dt>
<dd>
<div class="desc"><p>Method to output the background and skills</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[Union[None, str], Union[None, Skills]]</code></dt>
<dd>The background and skills of the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def background_skills(self) -&gt; Tuple[Union[None, str], Union[None, Skills]]:
    &#34;&#34;&#34;Method to output the background and skills

    Returns:
        Tuple[Union[None, str], Union[None, Skills]]: The background and skills of the player
    &#34;&#34;&#34;
    background_skills = self.soup.find(&#34;div&#34;, class_=&#34;background-and-skills&#34;)
    background = self._examine_background(background_skills)
    skills = self._examine_skills(background_skills)
    return background, skills</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="recruits.ncaaf.utils.CollegeRecruitingInterest"><code class="flex name class">
<span>class <span class="ident">CollegeRecruitingInterest</span></span>
<span>(</span><span>soup: bs4.BeautifulSoup)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CollegeRecruitingInterest:
    def __init__(self, soup: BeautifulSoup):
        self.soup = soup
    
    def _examine_more_colleges(self, url: str) -&gt; List[CollegeInterest]:
        &#34;&#34;&#34;Method to parse over page if there is long list of colleges. Congrats!

        Args:
            url (str): the url to the webpage that contains list of colleges

        Returns:
            List[CollegeInterest]: Data of all colleges that actively recruited recruit
        &#34;&#34;&#34;
        school_list = []
        page = requests.get(url, headers=HEADERS)
        soup = BeautifulSoup(page.content, &#34;html.parser&#34;)
        interests = soup.find(&#34;ul&#34;, class_ = &#34;recruit-interest-index_lst&#34;)
        first_blocks = interests.find_all(&#34;div&#34;, class_=&#39;first_blk&#39;)
        second_blocks = interests.find_all(&#39;div&#39;, class_=&#39;secondary_blk&#39;)
        for first_block, second_block in zip(first_blocks, second_blocks):
            
            # collect college name
            first_block_a = first_block.find_all(&#39;a&#39;)
            college_name = &#34;&#34;.join(first_block_a[0].text.split())

            # collect college statuses
            college_status = first_block.find(&#39;span&#39;, class_ = &#39;status&#39;)
            college_status_text = college_status.find(&#39;span&#39;, class_=&#39;grey&#39;)
            if college_status_text:
                college_status_text = &#34;Signed&#34;
            else:
                college_status_text = college_status.find(&#39;span&#39;).text
            
            # collect the status of signature or not
            college_status_date = college_status.find(&#34;a&#34;)
            if college_status_date:
                college_status_date = college_status_date.text
                college_status_date = college_status_date.translate(str.maketrans(&#34;&#34;, &#34;&#34;, &#34;()&#34;))
            else:
                college_status_date = None

            # collect visit
            visit = second_block.find(&#39;span&#39;, class_=&#39;visit&#39;).text
            if &#39;-&#39; in visit:
                visit = None
            
            # collect offer
            offer = second_block.find(&#39;span&#39;, class_=&#39;offer&#39;).text.strip()
            if &#39;yes&#39; in offer.lower():
                offer = True
            else:
                offer = False

            # collect recruited by
            recruited_by = second_block.find(&#34;ul&#34;, class_=&#39;interest-details_lst&#39;)
            if not recruited_by:
                recruiters = None
            else:
                recruited_by = recruited_by.find_all(&#34;li&#34;)[1:]
                recruiters = [Staff(url = recruiter.find(&#34;a&#34;)[&#39;href&#39;]).member for recruiter in recruited_by]

            school = CollegeInterest(
                college=college_name, status=college_status_text,
                status_date=college_status_date, visit=visit, offered=offer,
                recruited_by=recruiters
            )
            school_list.append(school)      
        return school_list

    @property
    def college_interest(self) -&gt; Union[None, List[CollegeInterest]]:
        &#34;&#34;&#34;Method to output the data of college

        Returns:
            Union[None, List[CollegeInterest]]: Data of all colleges interested in the recruit
        &#34;&#34;&#34;
        view_all_colleges = self.soup.find(&#39;a&#39;, class_ = &#34;college-comp__view-all&#34;)
        school_list = []
        if view_all_colleges:
            school_list = self._examine_more_colleges(view_all_colleges[&#39;href&#39;])
        else:
            school_list = None
        return school_list</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="recruits.ncaaf.utils.CollegeRecruitingInterest.college_interest"><code class="name">var <span class="ident">college_interest</span> : Optional[None]</code></dt>
<dd>
<div class="desc"><p>Method to output the data of college</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[None, List[CollegeInterest]]</code></dt>
<dd>Data of all colleges interested in the recruit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def college_interest(self) -&gt; Union[None, List[CollegeInterest]]:
    &#34;&#34;&#34;Method to output the data of college

    Returns:
        Union[None, List[CollegeInterest]]: Data of all colleges interested in the recruit
    &#34;&#34;&#34;
    view_all_colleges = self.soup.find(&#39;a&#39;, class_ = &#34;college-comp__view-all&#34;)
    school_list = []
    if view_all_colleges:
        school_list = self._examine_more_colleges(view_all_colleges[&#39;href&#39;])
    else:
        school_list = None
    return school_list</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="recruits.ncaaf.utils.Connections"><code class="flex name class">
<span>class <span class="ident">Connections</span></span>
<span>(</span><span>soup: bs4.BeautifulSoup)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Connections:
    def __init__(self, soup: BeautifulSoup):
        self.soup = soup
    
    @property
    def connections(self) -&gt; Union[None, List[Connection]]:
        &#34;&#34;&#34;Collect the connecions to the player

        Returns:
            Union[None, List[Connection]]: Data on the connections to the player
        &#34;&#34;&#34;
        pedigree = self.soup.find(&#39;section&#39;, class_ = &#39;pedigree&#39;)
        if not pedigree:
            return None

        pedigree = pedigree.find(&#39;div&#39;, class_ = &#39;body&#39;).find_all(&#39;li&#39;)
        connections = []
        for ped in pedigree:
            name = ped.find(&#39;a&#39;, class_ = &#39;name&#39;)
            if name:
                name = name.text
            else:
                name = ped.find(&#39;b&#39;, class_ = &#39;name&#39;).text

            relation = ped.find(&#39;span&#39;, class_ = &#39;relation&#39;).text
            accolades = ped.find(&#39;span&#39;, class_=&#39;accolades&#39;)
            accolades = &#34;&#34;.join([string for string in accolades.strings])
            connection = Connection(
                name = name, relation=relation, accolades=accolades
            )
            connections.append(connection)
        return connections</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="recruits.ncaaf.utils.Connections.connections"><code class="name">var <span class="ident">connections</span> : Optional[None]</code></dt>
<dd>
<div class="desc"><p>Collect the connecions to the player</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[None, List[Connection]]</code></dt>
<dd>Data on the connections to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connections(self) -&gt; Union[None, List[Connection]]:
    &#34;&#34;&#34;Collect the connecions to the player

    Returns:
        Union[None, List[Connection]]: Data on the connections to the player
    &#34;&#34;&#34;
    pedigree = self.soup.find(&#39;section&#39;, class_ = &#39;pedigree&#39;)
    if not pedigree:
        return None

    pedigree = pedigree.find(&#39;div&#39;, class_ = &#39;body&#39;).find_all(&#39;li&#39;)
    connections = []
    for ped in pedigree:
        name = ped.find(&#39;a&#39;, class_ = &#39;name&#39;)
        if name:
            name = name.text
        else:
            name = ped.find(&#39;b&#39;, class_ = &#39;name&#39;).text

        relation = ped.find(&#39;span&#39;, class_ = &#39;relation&#39;).text
        accolades = ped.find(&#39;span&#39;, class_=&#39;accolades&#39;)
        accolades = &#34;&#34;.join([string for string in accolades.strings])
        connection = Connection(
            name = name, relation=relation, accolades=accolades
        )
        connections.append(connection)
    return connections</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="recruits.ncaaf.utils.Evaluators"><code class="flex name class">
<span>class <span class="ident">Evaluators</span></span>
<span>(</span><span>soup: bs4.BeautifulSoup)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Evaluators:
    def __init__(self, soup: BeautifulSoup):
        self.soup = soup

    def _examine_multiple_evaluators(self, page: BeautifulSoup) -&gt; List[Evaluator]:
        &#34;&#34;&#34;Find evaluators data if the webpage allows for multiple evaluators

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            List[Evaluator]: Evaluator dataclasses of the evaluators found evaluating
            the recruit.
        &#34;&#34;&#34;

        evaluators = page.find(&#34;section&#34;, class_=&#34;main-content list-content&#34;)
        evaluators_list = evaluators.find(&#34;ul&#34;, class_=&#39;evaluation-list&#39;).find_all(&#34;li&#34;)
        evaluators_list = list()
        for evaluator in evaluators_list:
            eval_id = evaluator.get(&#39;id&#39;)
            eval_id = int(eval_id) if eval_id else None
            eval_list = evaluator.find(&#34;ul&#34;, class_ = &#34;highlights-list&#34;)
            if eval_list:

                # evaluator name and region0
                evaluator_eval = eval_list.find(&#34;li&#34;, class_=&#34;eval-meta evaluator&#34;)
                name = evaluator_eval.find(&#34;b&#34;, class_=&#34;text&#34;).text
                region = evaluator_eval.find(&#34;span&#34;, class_=&#34;uppercase&#34;).text

                # get projection
                evaluator_projection = eval_list.find(&#34;li&#34;, class_=&#34;eval-meta projection&#34;)
                projection = evaluator_projection.find(&#34;b&#34;, class_=&#34;text&#34;).text

                # get comparison
                evaluator_comparison = eval_list.find_all(&#39;li&#39;, class_=&#39;eval-meta&#39;, partial=False)[-1]
                comparison = evaluator_comparison.find(&#34;a&#34;, attrs = {&#34;target&#34;: &#34;_blank&#34;})
                if comparison:
                    comparison = comparison.text
                else:
                    comparison = None
                
                # see if there is a comparison team
                comparison_team = evaluator_comparison.find(&#34;span&#34;, class_=&#34;uppercase&#34;)
                if comparison_team:
                    comparison_team = comparison_team.text
                else:
                    comparison_team = None

                # get evaluation date and text
                evaluation_data = evaluator.find(&#34;p&#34;, class_=&#34;eval-text&#34;)
                evaluation_date = evaluation_data.find(&#34;strong&#34;, class_=&#34;eval-date&#34;).text.strip()
                evaluation_text = evaluation_data.text.strip().split(&#34;\n&#34;)[-1].strip()

                evaluators_dataclass = Evaluator(
                    id = eval_id, name = name, region = region, projection = projection, comparison=comparison,
                    comparison_team=comparison_team, evaluation_date=evaluation_date, evaluation=evaluation_text
                )
                evaluators_list.append(evaluators_dataclass)
        return evaluators_list

    def _examine_single_page_evaluators(self, page: BeautifulSoup) -&gt; Union[None, Evaluator]:
        &#34;&#34;&#34;Find evaluator if there is no external webpage.

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, Evaluator]: Evaluator data class that consists of Evaluator metadata
        &#34;&#34;&#34;
        # get highlights
        highlights = page.find(&#34;section&#34;, class_=&#34;highlights&#34;)
        if not highlights:
            return None

        # get evaluator metadata
        eval_date = highlights.find(&#39;div&#39;).find(&#39;h4&#39;).text.split(&#34; &#34;)[-1]
        evaluator = highlights.find(&#34;div&#34;, class_=&#39;evaluator&#39;)
        name = evaluator.find(&#34;b&#34;, class_=&#39;text&#39;).text
        region = evaluator.find(&#39;span&#39;, class_=&#39;uppercase&#39;).text

        # get projections
        projection = highlights.find(&#34;div&#34;, class_=&#39;projection&#39;).find(&#39;b&#39;).text

        # get comparison
        comparison = highlights.find_all(&#39;div&#39;)[-1]
        comparison_name = comparison.find(&#39;a&#39;).text
        comparison_team = comparison.find(&#34;span&#34;).text

        # get evaluations
        evaluation = page.find(&#34;p&#34;, class_=&#39;eval-text&#39;).get_text().strip()

        # store evaluation
        evaluators_dataclass = Evaluator(
            name = name, region = region, projection = projection, comparison=comparison_name,
            comparison_team=comparison_team, evaluation_date=eval_date, evaluation=evaluation
        )
        
        return evaluators_dataclass

    @property
    def evaluator(self) -&gt; Union[None, Tuple[List[Evaluator], Union[None, str], Union[None, Skills]], Tuple[Evaluator, Union[None, str], Union[None, Skills]]]:
        &#34;&#34;&#34;Output method to collect the Evaluators

        Returns:
            Union[None, 
                  Tuple[List[Evaluator], Union[None, str], Union[None, Skills]], 
                  Tuple[Evaluator, Union[None, str], Union[None, Skills]]]: Evaluator dataclasses with
                  the background and skills dataclasses embedded
        &#34;&#34;&#34;
        scouting_report = self.soup.find(&#34;section&#34;, class_=&#34;scouting-report&#34;)
        if not scouting_report:
            return None

        # collect evaluators
        evaluations = scouting_report.find(&#34;header&#34;).find(&#39;a&#39;, class_=&#39;view-all-eval-link&#39;)
        if evaluations:
            url = evaluations[&#39;href&#39;]
            page = requests.get(url, headers = HEADERS)
            soup = BeautifulSoup(page.content, &#39;lxml&#39;)
            evaluators_list = self._examine_multiple_evaluators(soup)
            background, skills = BackgroundSkills(scouting_report).background_skills

        else:
            evaluators = self.soup.find(&#39;section&#39;, class_=&#39;scouting-report&#39;)
            evaluators_list = self._examine_single_page_evaluators(evaluators)
            background, skills = BackgroundSkills(evaluators).background_skills

        return evaluators_list, background, skills</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="recruits.ncaaf.utils.Evaluators.evaluator"><code class="name">var <span class="ident">evaluator</span> : Union[ForwardRef(None), Tuple[List[<a title="recruits.ncaaf.datamodels.Evaluator" href="datamodels.html#recruits.ncaaf.datamodels.Evaluator">Evaluator</a>], Optional[None], Optional[None]], Tuple[<a title="recruits.ncaaf.datamodels.Evaluator" href="datamodels.html#recruits.ncaaf.datamodels.Evaluator">Evaluator</a>, Optional[None], Optional[None]]]</code></dt>
<dd>
<div class="desc"><p>Output method to collect the Evaluators</p>
<h2 id="returns">Returns</h2>
<dl>
<dt>Union[None,</dt>
<dt>Tuple[List[Evaluator], Union[None, str], Union[None, Skills]],</dt>
<dt><code>
Tuple[Evaluator, Union[None, str], Union[None, Skills]]]</code></dt>
<dd>Evaluator dataclasses with
the background and skills dataclasses embedded</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def evaluator(self) -&gt; Union[None, Tuple[List[Evaluator], Union[None, str], Union[None, Skills]], Tuple[Evaluator, Union[None, str], Union[None, Skills]]]:
    &#34;&#34;&#34;Output method to collect the Evaluators

    Returns:
        Union[None, 
              Tuple[List[Evaluator], Union[None, str], Union[None, Skills]], 
              Tuple[Evaluator, Union[None, str], Union[None, Skills]]]: Evaluator dataclasses with
              the background and skills dataclasses embedded
    &#34;&#34;&#34;
    scouting_report = self.soup.find(&#34;section&#34;, class_=&#34;scouting-report&#34;)
    if not scouting_report:
        return None

    # collect evaluators
    evaluations = scouting_report.find(&#34;header&#34;).find(&#39;a&#39;, class_=&#39;view-all-eval-link&#39;)
    if evaluations:
        url = evaluations[&#39;href&#39;]
        page = requests.get(url, headers = HEADERS)
        soup = BeautifulSoup(page.content, &#39;lxml&#39;)
        evaluators_list = self._examine_multiple_evaluators(soup)
        background, skills = BackgroundSkills(scouting_report).background_skills

    else:
        evaluators = self.soup.find(&#39;section&#39;, class_=&#39;scouting-report&#39;)
        evaluators_list = self._examine_single_page_evaluators(evaluators)
        background, skills = BackgroundSkills(evaluators).background_skills

    return evaluators_list, background, skills</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="recruits.ncaaf.utils.Ratings247"><code class="flex name class">
<span>class <span class="ident">Ratings247</span></span>
<span>(</span><span>soup: bs4.BeautifulSoup, pos: str, state: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ratings247:
    def __init__(self, soup: BeautifulSoup, pos: str, state: str):
        self.soup = soup
        self.pos = pos
        self.state = state

    def _find_ratings_composite_helper(self, soup: BeautifulSoup, it: BeautifulSoup) -&gt; Dict:
        &#34;&#34;&#34;Collect the composite ratings of the recruit (247Sports Composite)

        Args:
            soup (BeautifulSoup): webpage to be scraped
            it (BeautifulSoup): position on webpage

        Returns:
            Dict: data that consists of the different composite scores
        &#34;&#34;&#34;
        data = {}
        data[&#39;composite_score&#39;] = soup.find(&#34;div&#34;, class_ = &#34;rank-block&#34;).text
        if data[&#39;composite_score&#39;] == &#39;N/A&#39;:
            data[&#39;composite_score&#39;] = None
        else:
            data[&#39;composite_score&#39;] = float(&#34;&#34;.join(data[&#39;composite_score&#39;].split())) if data[&#39;composite_score&#39;] else None
        
        rank_list = it.find(&#34;ul&#34;, class_ = &#34;ranks-list&#34;).find_all(&#34;li&#34;)
        for rl in rank_list:
            rank_name, rank_value = rl.find(&#34;b&#34;).text, rl.find(&#34;a&#34;).find(&#34;strong&#34;).text
            if rank_value == &#39;N/A&#39;:
                rank_value = None

            if rank_name == &#39;Natl.&#39;:
                data[&#39;national_composite_rank&#39;] = int(rank_value) if rank_value else None
            if rank_name == self.pos:
                data[&#39;position_composite_rank&#39;] = int(rank_value) if rank_value else None
            if rank_name == self.state:
                data[&#39;state_composite_rank&#39;] = int(rank_value) if rank_value else None
        return data

    def _find_ratings_normal_helper(self, soup: BeautifulSoup, it: BeautifulSoup) -&gt; Dict:
        &#34;&#34;&#34;Collect the normal ratings of the recruit (247Sports)

        Args:
            soup (BeautifulSoup): webpage to be scraped
            it (BeautifulSoup): position on webpage

        Returns:
            Dict: data that consists of the different normal scores
        &#34;&#34;&#34;
        data = {}
        data[&#39;normal_score&#39;] = soup.find(&#34;div&#34;, class_ = &#34;rank-block&#34;).text.strip()
        if data[&#39;normal_score&#39;] == &#39;N/A&#39;:
            data[&#39;normal_score&#39;] = None
        else:
            data[&#39;normal_score&#39;] = float(&#34;&#34;.join(data[&#39;normal_score&#39;].split())) if data[&#39;normal_score&#39;] else None

        rank_list = it.find(&#34;ul&#34;, class_ = &#34;ranks-list&#34;).find_all(&#34;li&#34;)
        for rl in rank_list:
            rank_name, rank_value = rl.find(&#34;b&#34;).text, rl.find(&#34;a&#34;).find(&#34;strong&#34;).text
            # change n/a to None
            if rank_value == &#39;N/A&#39;:
                rank_value = None

            if rank_name == &#39;Natl.&#39;:
                data[&#39;national_normal_rank&#39;] = int(rank_value) if rank_value else None
            if rank_name == self.pos:
                data[&#39;position_normal_rank&#39;] = int(rank_value) if rank_value else None
            if rank_name == self.state:
                data[&#39;state_normal_rank&#39;] = int(rank_value) if rank_value else None
        return data

    @property
    def ratings(self) -&gt; Ratings:
        &#34;&#34;&#34;Method to output Ratings dataclass that consist of Normal and
        Composite ratings.

        Returns:
            Ratings: Ratings dataclass that consist of Normal and 
            composite ratings.
        &#34;&#34;&#34;
        ratings_sections = self.soup.find_all(&#34;section&#34;, class_ = &#34;rankings-section&#34;)
        data = {}
        for rs in ratings_sections:
            title = rs.find(&#34;h3&#34;, class_ = &#39;title&#39;).text
            if &#39;composite&#39; in title.lower():
                ranking = rs.find(&#34;div&#34;, class_ = &#34;ranking&#34;)
                new_data = self._find_ratings_composite_helper(ranking, rs)
                data.update(new_data)
                
            else:
                ranking = rs.find(&#34;div&#34;, class_ = &#34;ranking&#34;)
                new_data = self._find_ratings_normal_helper(ranking, rs)
                data.update(new_data)

        return Ratings(**data)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="recruits.ncaaf.utils.Ratings247.ratings"><code class="name">var <span class="ident">ratings</span> : <a title="recruits.ncaaf.datamodels.Ratings" href="datamodels.html#recruits.ncaaf.datamodels.Ratings">Ratings</a></code></dt>
<dd>
<div class="desc"><p>Method to output Ratings dataclass that consist of Normal and
Composite ratings.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Ratings</code></dt>
<dd>Ratings dataclass that consist of Normal and </dd>
</dl>
<p>composite ratings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ratings(self) -&gt; Ratings:
    &#34;&#34;&#34;Method to output Ratings dataclass that consist of Normal and
    Composite ratings.

    Returns:
        Ratings: Ratings dataclass that consist of Normal and 
        composite ratings.
    &#34;&#34;&#34;
    ratings_sections = self.soup.find_all(&#34;section&#34;, class_ = &#34;rankings-section&#34;)
    data = {}
    for rs in ratings_sections:
        title = rs.find(&#34;h3&#34;, class_ = &#39;title&#39;).text
        if &#39;composite&#39; in title.lower():
            ranking = rs.find(&#34;div&#34;, class_ = &#34;ranking&#34;)
            new_data = self._find_ratings_composite_helper(ranking, rs)
            data.update(new_data)
            
        else:
            ranking = rs.find(&#34;div&#34;, class_ = &#34;ranking&#34;)
            new_data = self._find_ratings_normal_helper(ranking, rs)
            data.update(new_data)

    return Ratings(**data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="recruits.ncaaf.utils.Staff"><code class="flex name class">
<span>class <span class="ident">Staff</span></span>
<span>(</span><span>name_id: str = None, url: str = None, soup: bs4.BeautifulSoup = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Staff class that produces the staff member given the webpage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Staff:
    &#34;&#34;&#34;Staff class that produces the staff member given the webpage
    &#34;&#34;&#34;
    def __init__(self, name_id:str = None, url:str = None, soup:BeautifulSoup = None):
        self.name_id = name_id
        self.url = url
        self.soup = soup
        self.page = self._gain_primary()

    def _gain_primary(self) -&gt; BeautifulSoup:
        &#34;&#34;&#34;Method to obtain the BeautifulSoup page

        Returns:
            BeautifulSoup: page given the different identifiers
        &#34;&#34;&#34;
              
        if self.url:
            page = requests.get(self.url, headers = HEADERS)
            soup = BeautifulSoup(page.content, &#39;html.parser&#39;)
            return soup
        
        if self.name_id:
            url = f&#34;https://247sports.com/Coach/{self.name_id}/&#34;
            page = requests.get(url, headers = HEADERS)
            soup = BeautifulSoup(page.content, &#39;html.parser&#39;)
            return soup
        
        return self.soup
        
    def _get_meta(self, page: BeautifulSoup) -&gt; Dict:
        &#34;&#34;&#34;Collect the metadata on the staff member

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Dict: metadata of the coach like job position, alma mater, and age
        &#34;&#34;&#34;
        data = {}

        # get name
        data[&#39;name&#39;] = page.find(&#39;h1&#39;, class_=&#39;name&#39;).text.strip()

        # get metrics
        metrics_list = page.find(&#34;ul&#34;, class_=&#39;metrics-list&#39;).find_all(&#39;li&#39;)
        for ml in metrics_list:
            met = ml.find_all(&#39;span&#39;)
            if met[0].text.lower() == &#39;job&#39;:
                data[&#39;position&#39;] = met[1].text.strip()

        # get alma mater
        coach_details = page.find(&#34;ul&#34;, class_=&#39;details coach&#39;)
        if coach_details:
            coach_details = coach_details.find_all(&#39;li&#39;)
            for cd in coach_details:
                if cd.get(&#39;class&#39;) == &#39;coach-alma-mater-item&#39;:
                    data[&#39;alma_mater&#39;] = cd.find_all(&#39;span&#39;)[-1].strip()

        # get vitals and team info
        team = page.find(&#39;section&#39;, class_=&#39;team-block&#39;)
        if team:
            data[&#39;college&#39;] = team.find(&#39;h2&#39;).text.strip()
            vitals = team.find(&#39;ul&#39;, class_=&#39;vitals&#39;).find_all(&#39;li&#39;)
            for v in vitals:
                v = v.find_all(&#39;span&#39;)
                if v[0] == &#39;Age&#39;:
                    data[&#39;staff_member_age&#39;] = int(v[1]) if v[1] else None

        return data
    
    def _get_ratings(self, page: BeautifulSoup) -&gt; Dict:
        &#34;&#34;&#34;Collect the ratings of the staff member

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Dict: Ratings data of the staff member like number of commits avg rank and so on.
        &#34;&#34;&#34;

        data = {}
        rankings = page.find(&#39;section&#39;, class_=&#39;rankings-section&#39;)
        if not rankings:
            return None
        
        rankings = rankings.find_all(&#39;li&#39;)
        non_conf = [&#34;commits&#34;, &#39;avg_rtg&#39;, &#39;natl_rk&#39;, &#39;star_5&#39;, &#39;star_4&#39;, &#39;star_3&#39;]
        for rank in rankings:
            # fix system to rearrange if the string starts with a number like 5
            rank_name = rank.find(&#39;b&#39;).text.replace(&#39;.&#39;, &#39;&#39;).replace(&#39; &#39;, &#39;_&#39;).replace(&#39;-&#39;, &#34;_&#34;).lower()
            if rank_name[0].isdigit():
                num, star = rank_name.split(&#39;_&#39;)
                rank_name = &#34;_&#34;.join([star, num])

            rank_value = rank.find(&#39;a&#39;)
            if rank_value:
                rank_value = rank_value.find(&#39;strong&#39;).text.strip()
                if rank_name in non_conf:
                    data[rank_name] = rank_value
                else:
                    data[&#39;conference&#39;] = rank_value
        return data

    def _get_top_commits(self, page: BeautifulSoup) -&gt; Union[None, List[TopCommit]]:
        &#34;&#34;&#34;Collect the top commits of the coach.

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, List[TopCommit]]: The metadata of the player if found
        &#34;&#34;&#34;
        commits = page.find_all(&#39;ul&#39;, class_=&#39;commits-details&#39;)
        if not commits:
            return None

        details = []
        for commit in commits:
            _, name, position, height_weight, rating, commitment = commit.find_all(&#34;li&#34;)

            # get name
            recruit_name = name.find(&#39;a&#39;, class_=&#39;player&#39;).text
            location = &#39; &#39;.join([string.strip() for string in name.find_all(&#34;span&#34;)])

            # position
            position = position.find(&#39;span&#39;).text.strip()

            # find height and weight
            height, weight = height_weight.find(&#39;span&#39;).text.split(&#34; / &#34;)

            # find rating and stars
            stars = len(rating.find_all(&#34;span&#34;, class_=&#34;icon-starsolid yellow&#34;))
            rating = float(rating.find(&#39;span&#39;, class_=&#34;rating&#34;).text)

            # find commitment
            college = commitment.find(&#34;a&#34;, class_=&#39;player-institution&#39;).find(&#39;img&#39;)[&#39;alt&#39;].strip()
            commitment_date = commitment.find(&#34;span&#34;, class_=&#39;commit-date&#39;).text.strip()

            commit = TopCommit(
                name = recruit_name, location = location, position = position,
                height = height, weight = weight, stars = stars, rating = rating,
                college = college, commitment_date = commitment_date
            )
            details.append(commit)

        return details

    def _get_coach_history(self, page: BeautifulSoup) -&gt; Union[None, List[CoachHistory]]:
        &#34;&#34;&#34;Collect the history of the coach such as job positions

        Args:
            page (BeautifulSoup): webpage to be scraped

        Returns:
            Union[None, List[CoachHistory]]: _description_
        &#34;&#34;&#34;
        coach_history = page.find(&#34;section&#34;, class_=&#39;coach-history&#39;)
        if not coach_history:
            return None
        
        coach_history = coach_history.find(&#39;div&#39;, class_=&#39;body&#39;).find_all(&#39;li&#39;)
        data = []
        for position in coach_history:
            college, (years, job) = position.find(&#39;img&#39;)[&#39;alt&#39;], position.find_all(&#39;span&#39;)
            years, job = years.text.strip(), job.text.strip()

            coachhistory = CoachHistory(college=college, year=years, position=job)
            data.append(coachhistory)
        return data

    @property
    def member(self) -&gt; StaffMember:
        &#34;&#34;&#34;Output property for the Staff Member

        Returns:
            StaffMember: Staffmember dataclass that contains the just collected data
        &#34;&#34;&#34;
        meta = self._get_meta(self.page)
        ratings = self._get_ratings(self.page)
        commits = self._get_top_commits(self.page)
        coach_history = self._get_coach_history(self.page)

        if ratings:
            return StaffMember(
                **meta, **ratings, top_commits=commits, coach_history=coach_history
            )
        else:
            return StaffMember(
                **meta, top_commits=commits, coach_history=coach_history
            )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="recruits.ncaaf.utils.Staff.member"><code class="name">var <span class="ident">member</span> : <a title="recruits.ncaaf.datamodels.StaffMember" href="datamodels.html#recruits.ncaaf.datamodels.StaffMember">StaffMember</a></code></dt>
<dd>
<div class="desc"><p>Output property for the Staff Member</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>StaffMember</code></dt>
<dd>Staffmember dataclass that contains the just collected data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def member(self) -&gt; StaffMember:
    &#34;&#34;&#34;Output property for the Staff Member

    Returns:
        StaffMember: Staffmember dataclass that contains the just collected data
    &#34;&#34;&#34;
    meta = self._get_meta(self.page)
    ratings = self._get_ratings(self.page)
    commits = self._get_top_commits(self.page)
    coach_history = self._get_coach_history(self.page)

    if ratings:
        return StaffMember(
            **meta, **ratings, top_commits=commits, coach_history=coach_history
        )
    else:
        return StaffMember(
            **meta, top_commits=commits, coach_history=coach_history
        )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="recruits.ncaaf" href="index.html">recruits.ncaaf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="recruits.ncaaf.utils.BackgroundSkills" href="#recruits.ncaaf.utils.BackgroundSkills">BackgroundSkills</a></code></h4>
<ul class="">
<li><code><a title="recruits.ncaaf.utils.BackgroundSkills.background_skills" href="#recruits.ncaaf.utils.BackgroundSkills.background_skills">background_skills</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="recruits.ncaaf.utils.CollegeRecruitingInterest" href="#recruits.ncaaf.utils.CollegeRecruitingInterest">CollegeRecruitingInterest</a></code></h4>
<ul class="">
<li><code><a title="recruits.ncaaf.utils.CollegeRecruitingInterest.college_interest" href="#recruits.ncaaf.utils.CollegeRecruitingInterest.college_interest">college_interest</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="recruits.ncaaf.utils.Connections" href="#recruits.ncaaf.utils.Connections">Connections</a></code></h4>
<ul class="">
<li><code><a title="recruits.ncaaf.utils.Connections.connections" href="#recruits.ncaaf.utils.Connections.connections">connections</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="recruits.ncaaf.utils.Evaluators" href="#recruits.ncaaf.utils.Evaluators">Evaluators</a></code></h4>
<ul class="">
<li><code><a title="recruits.ncaaf.utils.Evaluators.evaluator" href="#recruits.ncaaf.utils.Evaluators.evaluator">evaluator</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="recruits.ncaaf.utils.Ratings247" href="#recruits.ncaaf.utils.Ratings247">Ratings247</a></code></h4>
<ul class="">
<li><code><a title="recruits.ncaaf.utils.Ratings247.ratings" href="#recruits.ncaaf.utils.Ratings247.ratings">ratings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="recruits.ncaaf.utils.Staff" href="#recruits.ncaaf.utils.Staff">Staff</a></code></h4>
<ul class="">
<li><code><a title="recruits.ncaaf.utils.Staff.member" href="#recruits.ncaaf.utils.Staff.member">member</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>